LoadPackage("SgpDec");

# generators
u := ( 1, 3, 8, 6)( 2, 5, 7, 4)( 9,33,25,17)(10,34,26,18)(11,35,27,19);
d := (41,43,48,46)(42,45,47,44)(14,22,30,38)(15,23,31,39)(16,24,32,40);
l := ( 9,11,16,14)(10,13,15,12)( 1,17,41,40)( 4,20,44,37)( 6,22,46,35);
r := (25,27,32,30)(26,29,31,28)( 3,38,43,19)( 5,36,45,21)( 8,33,48,24);
f := (17,19,24,22)(18,21,23,20)( 6,25,43,16)( 7,28,42,13)( 8,30,41,11);
b := (33,35,40,38)(34,37,39,36)( 3, 9,46,32)( 2,12,47,29)( 1,14,48,27);

# defining the group
G := Group(u, d, l, r, f, b); 
Display(Size(G));

# subgroups
H := Subgroup(G, [u, d]); # subgroup generated by two "independent" generators
Display(StructureDescription(H)); 
K := Subgroup(G, [f, l]); # subgroup generated by two "dependent" generators
Display(Size(K));
L := Subgroup(G, [u, f, l]); # subgroup generated by three "dependent" generators
Display(Size(L));

# orbits
orbits := Orbits(G);
Display(orbits);

# composition series
series := CompositionSeries(G);
n := Size(series);
DisplayCompositionSeries(G);

# component actions of composition factors
for i in [1..n-1] do
  Print("Action of G");
  Print(i);
  Print("/G");
  Display(i+1);
  component := NaturalHomomorphismByNormalSubgroup(series[i], series[i+1]);
  Display(component);
od;

# right coset representatives
all_coset_reps := [];
for i in [1..n-1] do
  Print("Coset representatives of factor ");
  Display(i);
  if i <> 2 and i <> 10 then # these are too big!
    coset_reps := List(RightTransversal(series[i], series[i+1]), j->CanonicalRightCosetElement(series[i+1], j));
    Display(coset_reps);
    UniteSet(all_coset_reps, coset_reps);
  else
    Print("Too many! (output not shown)\n");
  fi;
od;

hom := EpimorphismFromFreeGroup(G:names:=["u","d","l","r","f","b"]);

# coset representatives in terms of the generators
for rep in all_coset_reps do
  Print("Representation of ");
  Display(rep);
  Display(PreImagesRepresentative(hom, rep));
od;

# macros for interesting configurations
lst1 := [(4,10)(5,26), # flip two opposite edge cubies on the same face
         (2,34)(5,26), # flip two adjacent edge cubies on the same face
         (5,26)(39,47), # flip two edge cubies on adjacent faces
         (7,18)(39,47), # flip two diametrically opposite edge cubies
         (4,5)(10,26)(2,7)(18,34), # swap opposite pairs of edge cubies on a face
         (1,8)(9,25)(35,19)(3,6)(11,27)(17,33), # swap opposite pairs of corner cubies on a face
         (1,9,35)(8,19,25) # rotate two opposite corner cubies on the same face in reverse orientation
        ];
for conf in lst1 do
  Print("Representation of ");
  Display(conf);
  Display(PreImagesRepresentative(hom, conf));
od;

# some impossible configurations
lst2 := [(4,10), # flip a single edge cubie
         (1,9,35), # rotate a single corner cubie
         (4,5)(10,26), # swap two opposite edge cubies on the same face
         (4,31)(10,45), # swap two diametrically opposite edge cubies
         (1,8)(9,25)(35,19), # swap two opposite corner cubies on the same face
         (1,43)(9,24)(35,30), # swap two diametrically opposite corner cubies
         (1,9,35)(8,25,19), # rotate two opposite corner cubies on the same face in same orientation
         (1,9,35)(24,30,43) # rotate two diametrically opposite corner cubies in same orientation
        ];
for conf in lst2 do
  Print("Checking ");
  Display(conf);
  Display(conf in G);
od;
